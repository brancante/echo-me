# Echo Me - Database Schema

## Overview

Echo Me uses two primary databases:
1. **PostgreSQL** - Structured data (users, personas, products, conversations)
2. **ChromaDB/Qdrant** - Vector embeddings (RAG product search, persona transcripts)

---

## PostgreSQL Schema

### Entity Relationship Diagram (ASCII)

```
┌─────────────────┐
│     users       │
│─────────────────│
│ id (PK)         │◄────┐
│ email           │     │
│ name            │     │
│ image           │     │
│ created_at      │     │
│ updated_at      │     │
└─────────────────┘     │
                        │
        ┌───────────────┼───────────────┬───────────────┬───────────────┐
        │               │               │               │               │
        │ (1:N)         │ (1:N)         │ (1:N)         │ (1:N)         │ (1:N)
        ▼               ▼               ▼               ▼               ▼
┌─────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│  personas   │ │   products   │ │   clients    │ │  api_keys    │ │    jobs      │
│─────────────│ │──────────────│ │──────────────│ │──────────────│ │──────────────│
│ id (PK)     │ │ id (PK)      │ │ id (PK)      │ │ id (PK)      │ │ id (PK)      │
│ user_id (FK)│ │ user_id (FK) │ │ user_id (FK) │ │ user_id (FK) │ │ user_id (FK) │
│ name        │ │ catalog_id   │ │ name         │ │ service      │ │ type         │
│ role        │ │ name         │ │ email        │ │ encrypted    │ │ status       │
│ voice_id    │ │ description  │ │ telegram_id  │ │ last_4       │ │ progress     │
│ youtube_url │ │ price        │ │ phone        │ │ created_at   │ │ metadata     │
│ language    │ │ currency     │ │ notes        │ └──────────────┘ │ created_at   │
│ status      │ │ sku          │ │ metadata     │                  │ completed_at │
│ created_at  │ │ category     │ │ created_at   │                  │ failed_at    │
│ updated_at  │ │ in_stock     │ │ updated_at   │                  │ error        │
└──────┬──────┘ │ metadata     │ └──────┬───────┘                  └──────────────┘
       │        │ created_at   │        │
       │        └──────┬───────┘        │
       │               │                │
       │ (1:1)         │ (1:N)          │ (1:N)
       ▼               ▼                ▼
┌─────────────────┐ ┌──────────────────┐ ┌──────────────────┐
│ persona_profiles│ │ product_chunks   │ │ conversations    │
│─────────────────│ │──────────────────│ │──────────────────│
│ id (PK)         │ │ id (PK)          │ │ id (PK)          │
│ persona_id (FK) │ │ product_id (FK)  │ │ persona_id (FK)  │
│ auto_extracted  │ │ content          │ │ client_id (FK)   │
│ manual_overrides│ │ chunk_index      │ │ channel          │
│ created_at      │ │ metadata         │ │ started_at       │
│ updated_at      │ │ created_at       │ │ ended_at         │
└─────────────────┘ └──────────────────┘ │ message_count    │
                                         └─────────┬────────┘
                                                   │
                                                   │ (1:N)
                                                   ▼
                                         ┌─────────────────┐
                                         │    messages     │
                                         │─────────────────│
                                         │ id (PK)         │
                                         │ conversation_id │
                                         │ sender          │
                                         │ content         │
                                         │ audio_url       │
                                         │ rag_context     │
                                         │ tokens_used     │
                                         │ created_at      │
                                         └─────────────────┘
```

---

## Table Definitions

### `users`
Stores authenticated user accounts.

```sql
CREATE TABLE users (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'usr_abc123'
    email           VARCHAR(255) UNIQUE NOT NULL,
    name            VARCHAR(255),
    image           TEXT,                                -- Google profile picture URL
    email_verified  TIMESTAMP,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

**Columns:**
- `id`: Unique user identifier (generated by NextAuth.js)
- `email`: Google OAuth email (unique)
- `name`: Full name from Google profile
- `image`: Profile picture URL
- `email_verified`: Timestamp when email was verified (OAuth auto-verifies)

**Notes:**
- Managed by NextAuth.js (auto-creates during OAuth flow)
- `email` is unique and indexed for fast lookups

---

### `personas`
Stores persona metadata (voice ID, YouTube source, status).

```sql
CREATE TABLE personas (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'persona_def456'
    user_id         VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name            VARCHAR(255) NOT NULL,              -- e.g., 'John Sales Expert'
    role            VARCHAR(255),                       -- e.g., 'Founder & CEO'
    voice_id        VARCHAR(255),                       -- ElevenLabs voice ID
    youtube_url     TEXT NOT NULL,
    language        VARCHAR(10) DEFAULT 'en',           -- ISO 639-1 code
    status          VARCHAR(50) DEFAULT 'pending',      -- pending|processing|active|failed
    error_message   TEXT,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_personas_user_id ON personas(user_id);
CREATE INDEX idx_personas_status ON personas(status);
```

**Columns:**
- `id`: Unique persona identifier
- `user_id`: Owner (foreign key → users.id)
- `name`: Display name for the persona
- `role`: Job title or role description
- `voice_id`: ElevenLabs voice ID (null until cloning completes)
- `youtube_url`: Source video URL
- `language`: Primary language of the persona
- `status`: Lifecycle state:
  - `pending`: Initial state (job queued)
  - `processing`: Voice cloning in progress
  - `active`: Ready to use
  - `failed`: Error during processing
- `error_message`: Error details if status = failed

**Constraints:**
- Foreign key: `user_id` → `users.id` (CASCADE delete)
- Unique: (user_id, youtube_url) — prevent duplicate clones

---

### `persona_profiles`
Stores persona characteristics (auto-extracted + manual overrides).

```sql
CREATE TABLE persona_profiles (
    id                  SERIAL PRIMARY KEY,
    persona_id          VARCHAR(255) UNIQUE NOT NULL REFERENCES personas(id) ON DELETE CASCADE,
    auto_extracted      JSONB NOT NULL DEFAULT '{}',    -- LLM-extracted profile
    manual_overrides    JSONB NOT NULL DEFAULT '{}',    -- User edits
    created_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_persona_profiles_persona_id ON persona_profiles(persona_id);
CREATE INDEX idx_auto_extracted_gin ON persona_profiles USING GIN (auto_extracted);
CREATE INDEX idx_manual_overrides_gin ON persona_profiles USING GIN (manual_overrides);
```

**Columns:**
- `persona_id`: One-to-one relationship with personas
- `auto_extracted`: JSON blob with LLM-extracted characteristics:
  ```json
  {
    "speech_patterns": {
      "catchphrases": ["Let me tell you", "Here's the thing"],
      "filler_words": ["um", "you know"],
      "expressions": ["That's a great question"]
    },
    "vocabulary": {
      "level": "professional",
      "style": "conversational",
      "technical_terms": ["ROI", "conversion rate"],
      "slang": ["game-changer"]
    },
    "tone": {
      "formality": "casual-professional",
      "energy": "enthusiastic",
      "humor": "occasional",
      "empathy": "high"
    },
    "selling_style": {
      "approach": "storytelling + data",
      "primary_methods": ["case studies", "social proof"]
    },
    "greeting_closing": {
      "typical_greetings": ["Hey there!"],
      "typical_closings": ["Let me know if you have questions!"]
    }
  }
  ```

- `manual_overrides`: User-edited fields:
  ```json
  {
    "personality_traits": ["Friendly", "Technical expert"],
    "tone_guidelines": "Always enthusiastic",
    "dos": ["Always mention free shipping"],
    "donts": ["Never badmouth competitors"],
    "custom_expressions": ["Our customers love this!"],
    "backstory": "Founded in 2018...",
    "context_notes": "Specializes in eco-friendly products"
  }
  ```

**Notes:**
- GIN indexes enable fast JSONB queries (e.g., searching for specific traits)
- Final persona = merge(auto_extracted, manual_overrides) — manual takes precedence

---

### `products`
Product catalog metadata.

```sql
CREATE TABLE products (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'prod_abc123'
    user_id         VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    catalog_id      VARCHAR(255),                       -- e.g., 'catalog_spring2025'
    name            VARCHAR(500) NOT NULL,
    description     TEXT,
    price           DECIMAL(10, 2),
    currency        VARCHAR(10) DEFAULT 'USD',
    sku             VARCHAR(255),
    category        VARCHAR(255),
    in_stock        BOOLEAN DEFAULT TRUE,
    metadata        JSONB DEFAULT '{}',                 -- Flexible fields (color, size, etc.)
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_products_user_id ON products(user_id);
CREATE INDEX idx_products_catalog_id ON products(catalog_id);
CREATE INDEX idx_products_category ON products(category);
CREATE INDEX idx_products_in_stock ON products(in_stock);
CREATE INDEX idx_products_metadata_gin ON products USING GIN (metadata);

-- Full-text search
CREATE INDEX idx_products_name_tsvector ON products USING GIN (to_tsvector('english', name));
CREATE INDEX idx_products_description_tsvector ON products USING GIN (to_tsvector('english', description));
```

**Columns:**
- `catalog_id`: Groups products from same upload (optional)
- `metadata`: JSON for flexible attributes (color, size, material, etc.)

**Full-Text Search:**
- tsvector indexes enable fast `LIKE` and full-text queries
- Example query:
  ```sql
  SELECT * FROM products 
  WHERE to_tsvector('english', name || ' ' || description) 
        @@ to_tsquery('english', 'waterproof & notebook');
  ```

---

### `product_chunks`
Chunked product data for RAG embeddings.

```sql
CREATE TABLE product_chunks (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'chunk_abc123'
    product_id      VARCHAR(255) NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    content         TEXT NOT NULL,                      -- Chunked text
    chunk_index     INTEGER NOT NULL,                   -- Order within product
    token_count     INTEGER,
    metadata        JSONB DEFAULT '{}',                 -- Chunk-specific metadata
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_product_chunks_product_id ON product_chunks(product_id);
CREATE INDEX idx_product_chunks_chunk_index ON product_chunks(product_id, chunk_index);
```

**Columns:**
- `content`: Text chunk (max 512 tokens by default)
- `chunk_index`: Position in document (0-based)
- `token_count`: Number of tokens in chunk (for cost estimation)
- `metadata`: Chunk-level info (e.g., page number for PDFs)

**Example Row:**
```
id: chunk_001
product_id: prod_waterproof_nb
content: "AquaGuard Notebook features synthetic water-resistant pages..."
chunk_index: 0
token_count: 87
metadata: {"page": 1, "section": "Features"}
```

---

### `clients`
Customer/client profiles for personalized responses.

```sql
CREATE TABLE clients (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'client_abc123'
    user_id         VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name            VARCHAR(255) NOT NULL,
    email           VARCHAR(255),
    telegram_id     VARCHAR(255),                       -- Telegram user ID
    phone           VARCHAR(50),
    notes           TEXT,                               -- Manual notes (preferences, history)
    metadata        JSONB DEFAULT '{}',                 -- Company, role, custom fields
    last_contact    TIMESTAMP,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_clients_user_id ON clients(user_id);
CREATE INDEX idx_clients_telegram_id ON clients(telegram_id);
CREATE INDEX idx_clients_email ON clients(email);
CREATE UNIQUE INDEX idx_clients_user_telegram ON clients(user_id, telegram_id) WHERE telegram_id IS NOT NULL;
```

**Columns:**
- `telegram_id`: Telegram user ID (for Telegram bot lookups)
- `notes`: Free-text field for user to add context (e.g., "Prefers eco-friendly products")
- `metadata`: Structured custom fields:
  ```json
  {
    "company": "GreenTech Inc",
    "role": "Procurement Manager",
    "tags": ["vip", "bulk-buyer"]
  }
  ```
- `last_contact`: Auto-updated on each conversation

**Unique Constraint:**
- (user_id, telegram_id) — one client per Telegram user per Echo Me user

---

### `api_keys`
Encrypted API keys (ElevenLabs, OpenAI, Telegram).

```sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE api_keys (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'key_elevenlabs'
    user_id         VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    service         VARCHAR(50) NOT NULL,               -- elevenlabs|openai|telegram|anthropic
    encrypted_key   TEXT NOT NULL,                      -- pgp_sym_encrypt(api_key, secret)
    last_4_chars    VARCHAR(10),                        -- Last 4 chars for display
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_api_keys_user_id ON api_keys(user_id);
CREATE UNIQUE INDEX idx_api_keys_user_service ON api_keys(user_id, service);
```

**Encryption:**
```sql
-- Insert encrypted key
INSERT INTO api_keys (id, user_id, service, encrypted_key, last_4_chars)
VALUES (
    'key_abc',
    'usr_123',
    'elevenlabs',
    pgp_sym_encrypt('sk_abc123...', 'encryption_secret'),
    '...xyz'
);

-- Decrypt key
SELECT pgp_sym_decrypt(encrypted_key::bytea, 'encryption_secret') AS api_key
FROM api_keys
WHERE user_id = 'usr_123' AND service = 'elevenlabs';
```

**Notes:**
- `encryption_secret` stored in environment variable (not in DB)
- `last_4_chars` displayed in UI to identify keys

---

### `jobs`
Background job queue tracking.

```sql
CREATE TABLE jobs (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'job_voice_abc123'
    user_id         VARCHAR(255) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type            VARCHAR(50) NOT NULL,               -- voice_clone|persona_extract|rag_ingest
    status          VARCHAR(50) DEFAULT 'pending',      -- pending|processing|completed|failed|cancelled
    progress        INTEGER DEFAULT 0,                  -- 0-100%
    metadata        JSONB DEFAULT '{}',                 -- Job-specific data
    result          JSONB,                              -- Output data (on completion)
    error           JSONB,                              -- Error details (on failure)
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at      TIMESTAMP,
    completed_at    TIMESTAMP,
    failed_at       TIMESTAMP
);

CREATE INDEX idx_jobs_user_id ON jobs(user_id);
CREATE INDEX idx_jobs_status ON jobs(status);
CREATE INDEX idx_jobs_type ON jobs(type);
CREATE INDEX idx_jobs_created_at ON jobs(created_at DESC);
```

**Columns:**
- `type`: Job category (voice_clone, persona_extract, rag_ingest, etc.)
- `status`: Lifecycle state
- `progress`: 0-100 (for progress bars in UI)
- `metadata`: Input data:
  ```json
  {
    "youtube_url": "https://youtube.com/...",
    "persona_id": "persona_def456"
  }
  ```
- `result`: Output on success:
  ```json
  {
    "voice_id": "21m00Tcm4TlvDq8ikWAM",
    "duration_seconds": 185
  }
  ```
- `error`: Error details on failure:
  ```json
  {
    "code": "elevenlabs_quota_exceeded",
    "message": "API quota exceeded",
    "retry_after_seconds": null
  }
  ```

**Cleanup:**
- Auto-delete completed/failed jobs after 30 days (cron job)

---

### `conversations`
Tracks customer conversations across channels.

```sql
CREATE TABLE conversations (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'conv_abc123'
    persona_id      VARCHAR(255) NOT NULL REFERENCES personas(id) ON DELETE CASCADE,
    client_id       VARCHAR(255) REFERENCES clients(id) ON DELETE SET NULL,
    channel         VARCHAR(50) NOT NULL,               -- telegram|email|whatsapp
    started_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ended_at        TIMESTAMP,
    message_count   INTEGER DEFAULT 0,
    metadata        JSONB DEFAULT '{}'                  -- Channel-specific data
);

CREATE INDEX idx_conversations_persona_id ON conversations(persona_id);
CREATE INDEX idx_conversations_client_id ON conversations(client_id);
CREATE INDEX idx_conversations_channel ON conversations(channel);
CREATE INDEX idx_conversations_started_at ON conversations(started_at DESC);
```

**Columns:**
- `channel`: Source channel (telegram, email, whatsapp)
- `ended_at`: Null = active conversation, timestamp = ended
- `message_count`: Total messages in conversation (cached for analytics)
- `metadata`: Channel-specific info:
  ```json
  {
    "telegram_chat_id": "123456789",
    "telegram_username": "alice_johnson"
  }
  ```

---

### `messages`
Individual messages within conversations.

```sql
CREATE TABLE messages (
    id              VARCHAR(255) PRIMARY KEY,           -- e.g., 'msg_abc123'
    conversation_id VARCHAR(255) NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    sender          VARCHAR(50) NOT NULL,               -- user|persona
    content         TEXT NOT NULL,
    audio_url       TEXT,                               -- TTS audio (if persona replied)
    rag_context     JSONB,                              -- RAG hits used for response
    tokens_used     JSONB,                              -- Token usage stats
    processing_time_ms INTEGER,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at DESC);
```

**Columns:**
- `sender`: `"user"` (customer) or `"persona"` (AI response)
- `content`: Message text
- `audio_url`: Generated TTS audio URL (persona messages only)
- `rag_context`: RAG results used to generate response:
  ```json
  [
    {
      "product_id": "prod_abc",
      "chunk": "Product description...",
      "similarity_score": 0.89
    }
  ]
  ```
- `tokens_used`: LLM token breakdown:
  ```json
  {
    "prompt": 1240,
    "completion": 95,
    "total": 1335
  }
  ```
- `processing_time_ms`: Time to generate response (for analytics)

---

## ChromaDB / Qdrant Schema

### Collections

#### `product_embeddings_{user_id}`
Stores product chunk embeddings for RAG search.

**Schema:**
- `id`: Chunk ID (e.g., `"chunk_abc123"`)
- `embedding`: Vector (1536-dim for OpenAI, 384-dim for local models)
- `metadata`:
  ```json
  {
    "product_id": "prod_abc123",
    "product_name": "Eco-Friendly Notebook A5",
    "chunk_index": 0,
    "content": "AquaGuard Notebook features...",
    "category": "Stationery",
    "price": 12.99,
    "in_stock": true
  }
  ```

**Query Example (ChromaDB Python):**
```python
collection = chroma_client.get_collection(f"product_embeddings_{user_id}")
results = collection.query(
    query_embeddings=[query_vector],
    n_results=10,
    where={"in_stock": True}  # Filter by metadata
)
```

---

#### `persona_transcripts_{user_id}`
Stores persona transcript embeddings (for multi-video persona analysis).

**Schema:**
- `id`: Transcript segment ID (e.g., `"transcript_seg_001"`)
- `embedding`: Vector (same dimensions as product embeddings)
- `metadata`:
  ```json
  {
    "persona_id": "persona_def456",
    "youtube_url": "https://youtube.com/watch?v=abc",
    "segment_index": 0,
    "content": "Hey everyone, today I want to talk about...",
    "timestamp_start": 0,
    "timestamp_end": 30
  }
  ```

**Use Case:**
- Future feature: Analyze multiple YouTube videos to build comprehensive persona
- Query similar speech patterns across multiple sources

---

## Indexes & Performance

### PostgreSQL Performance Tuning

#### Composite Indexes
```sql
-- Fast lookup: user's active personas
CREATE INDEX idx_personas_user_active ON personas(user_id, status) WHERE status = 'active';

-- Fast lookup: user's in-stock products
CREATE INDEX idx_products_user_in_stock ON products(user_id, in_stock) WHERE in_stock = TRUE;

-- Fast lookup: recent conversations by persona
CREATE INDEX idx_conversations_persona_recent ON conversations(persona_id, started_at DESC);
```

#### Partial Indexes
```sql
-- Index only failed jobs (for retry logic)
CREATE INDEX idx_jobs_failed ON jobs(user_id, type) WHERE status = 'failed';

-- Index only active conversations
CREATE INDEX idx_conversations_active ON conversations(persona_id) WHERE ended_at IS NULL;
```

### ChromaDB Performance

#### Collection Sharding
- Separate collection per user: `product_embeddings_{user_id}`
- Avoids metadata filtering overhead
- Easier to delete user data (just drop collection)

#### Distance Metric
- **Cosine similarity** (default): Best for normalized embeddings
- **L2 (Euclidean)**: Alternative, slightly faster
- **Inner product**: Use if embeddings are not normalized

#### HNSW Index Parameters (Qdrant)
```python
from qdrant_client.models import VectorParams, Distance

client.create_collection(
    collection_name=f"product_embeddings_{user_id}",
    vectors_config=VectorParams(
        size=1536,  # OpenAI embedding dimensions
        distance=Distance.COSINE,
        hnsw_config={
            "m": 16,  # Number of connections per element
            "ef_construct": 100  # Size of dynamic candidate list
        }
    )
)
```

---

## Data Lifecycle & Cleanup

### Temporary Data
- **Audio files** (downloads, TTS): Delete after 24 hours (cron job)
- **Pending jobs**: Cancel after 1 hour of inactivity

### Archival
- **Conversations**: Keep forever (valuable for analytics)
- **Messages**: Optional: Archive messages older than 1 year to separate table
- **Jobs**: Delete completed/failed jobs after 30 days

### User Deletion (GDPR Compliance)
```sql
-- Cascade delete handles most cleanup
DELETE FROM users WHERE id = 'usr_abc123';

-- Manually delete ChromaDB collections
DROP COLLECTION product_embeddings_usr_abc123;
DROP COLLECTION persona_transcripts_usr_abc123;

-- Delete file storage
rm -rf data/audio/usr_abc123/
rm -rf data/uploads/usr_abc123/
```

---

## Backup & Restore

### PostgreSQL Backup
```bash
# Daily backup (cron job)
pg_dump -U echo echome | gzip > backups/echome_$(date +%Y%m%d).sql.gz

# Restore
gunzip < backups/echome_20250218.sql.gz | psql -U echo echome
```

### ChromaDB Backup
```python
# Export collection to JSON
collection = chroma_client.get_collection(f"product_embeddings_{user_id}")
data = collection.get(include=["embeddings", "metadatas", "documents"])

import json
with open(f"backups/chroma_{user_id}.json", "w") as f:
    json.dump(data, f)

# Restore
with open(f"backups/chroma_{user_id}.json") as f:
    data = json.load(f)
    collection.add(
        ids=data["ids"],
        embeddings=data["embeddings"],
        metadatas=data["metadatas"],
        documents=data["documents"]
    )
```

---

## Migrations

### Schema Versioning
- Use **Prisma** (TypeScript) or **Alembic** (Python) for migrations
- Migration files stored in `db/migrations/`

### Example Migration (Alembic)
```python
# db/migrations/0001_add_persona_language.py
"""Add language column to personas table"""

from alembic import op
import sqlalchemy as sa

def upgrade():
    op.add_column('personas', sa.Column('language', sa.String(10), server_default='en'))

def downgrade():
    op.drop_column('personas', 'language')
```

### Running Migrations
```bash
# Generate migration
alembic revision --autogenerate -m "Add persona language"

# Apply migrations
alembic upgrade head

# Rollback
alembic downgrade -1
```

---

## Security Considerations

### SQL Injection Prevention
- **Always use parameterized queries**:
  ```python
  # ❌ BAD
  query = f"SELECT * FROM products WHERE name = '{user_input}'"
  
  # ✅ GOOD
  query = "SELECT * FROM products WHERE name = %s"
  cursor.execute(query, (user_input,))
  ```

### Row-Level Security (RLS)
```sql
-- Enable RLS on personas table
ALTER TABLE personas ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only see their own personas
CREATE POLICY personas_user_isolation ON personas
    FOR ALL
    USING (user_id = current_setting('app.current_user_id')::VARCHAR);

-- Set current user in session
SET app.current_user_id = 'usr_abc123';
```

### API Key Encryption
- Encryption key stored in env var: `DB_ENCRYPTION_SECRET`
- Rotate encryption key periodically (requires re-encrypting all keys)

---

## Analytics Queries

### Most Active Personas
```sql
SELECT p.name, p.id, COUNT(c.id) AS conversation_count
FROM personas p
LEFT JOIN conversations c ON p.id = c.persona_id
WHERE p.user_id = 'usr_abc123'
GROUP BY p.id
ORDER BY conversation_count DESC
LIMIT 10;
```

### Average Response Time
```sql
SELECT 
    AVG(processing_time_ms) AS avg_time_ms,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY processing_time_ms) AS median_time_ms,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY processing_time_ms) AS p95_time_ms
FROM messages
WHERE sender = 'persona' AND created_at > NOW() - INTERVAL '7 days';
```

### Token Usage by User
```sql
SELECT 
    u.email,
    SUM((m.tokens_used->>'total')::INTEGER) AS total_tokens,
    SUM((m.tokens_used->>'total')::INTEGER) * 0.00002 AS estimated_cost_usd
FROM messages m
JOIN conversations c ON m.conversation_id = c.id
JOIN personas p ON c.persona_id = p.id
JOIN users u ON p.user_id = u.id
WHERE m.created_at > NOW() - INTERVAL '30 days'
GROUP BY u.id
ORDER BY total_tokens DESC;
```

---

**Last updated:** 2025-02-18  
**Version:** 1.0 (MVP)
